#!/usr/bin/env perl
# ============================================================================
# NAME: crcheck
# DESC: A simple pre-commit script checking lint, unit tests, and code review.
#       This script is based on crpost/crfetch by Jay Buffington et. al. but
#       focuses on pre-commit/commit-time checks beyond simple code reviews.
# AUTH: Scott Shattuck (idearat@yahoo-inc.com)
# NOTE: Copyright (C) 2011, Yahoo Inc., All Rights Reserved.
# ----------------------------------------------------------------------------

# TODO: add 'e' flag for 'environment' dump without operation
# TODO: rework flags for lint only and test only per Chris's comments
# TODO: make -m optional. use git log etc. to build a viable message.
# TODO: options for 'non make' test operation? 
# TODO: leverage pipe/stdin for something appropriate?

use 5.008;

use strict;
use warnings;

# Add library reference to support running as a pre-commit hook. In that case
# there won't be any environment/path configured unless we do it manually.
use lib ( $ENV{'CRCCHECK_SITE_PERL'} || '/home/y/lib/perl5/site_perl');

use Yahoo::Config::DirTree;
use Yahoo::Bugzilla::Client;
use Yahoo::WebService::ReviewBoard::ReviewRequest;
use Cwd;
use File::Spec;
use Getopt::Long;
use Log::Log4perl qw(:easy);

# ----------------------------------------------------------------------------
# Global variables/constants etc.
# ----------------------------------------------------------------------------

# ---
# Command line argument variables.
# ---

my $all = 0;          # Activate both lint and unit testing...overrides.
my $bug_id;           # Can be parsed from commit message or command line.
my $commit = 0;       # Follow up successful precheck with an svn commit call.
my $force = 0;        # Force commit to happen regardless of test state.
my $lint = 0;         # Perform lint checking. Default is false.
my $message;          # Optional commit message (required with --commit flag).
my $test = 0;         # Turn on unit tests. Default is false to skip testing.
my $pre_review = 0;   # Set when no bug ID or review ID to skip ReviewBoard.
my $review_id;        # Can be parsed from commit message or command line.
my $verbose = 0;      # Turn on more verbose output logging (DEBUG vs. WARN).

# ---
# Constants / Magic Values
# ---

# Path to the Google Closure Linter.
my $glinter = $ENV{'CRCHECK_GOOGLE_LINTER'} || '/usr/local/bin/gjslint';

# Path to the Yahoo! jslint linter.
my $ylinter = $ENV{'CRCHECK_YAHOO_LINTER'} || '/home/y/bin/yjslint.sh';

# Linter to use in the Subversion pre-commit hook version [jslint].
my $linter = $ylinter;

# Makefile target to use for running tests via make.
my $maketarget = $ENV{'CRCHECK_MAKE_TARGET'} || 'test';

# Minimum number of ship-its required to allow a commit to proceed.
my $min_shipits = $ENV{'CRCHECK_MIN_SHIPITS'} || 1;

# Prefix used to short-circuit duplicate testing work in pre-commit hook.
my $prefix = $ENV{'CRCHECK_PREFIX'} || 'crcheck:';

# Path to the Yahoo! Subversion repository.
my $repo_default = $ENV{'CRCHECK_SVN_URL'} || "svn+ssh://svn.corp.yahoo.com";

# Path to the Yahoo! ReviewBoard server.
my $reviewboard = $ENV{'CRCHECK_RB_URL'} || 'http://codereview.corp.yahoo.com';

# Path to the default Subversion "svnlook" binary.
my $svnlook = $ENV{'CRCHECK_SVNLOOK'} || '/usr/bin/svnlook';

# ---
# Shared Globals
# ---

my $review = Yahoo::WebService::ReviewBoard::ReviewRequest->new($reviewboard);
my $review_exists;  # true when the review is found on ReviewBoard.
my $rr_id;          # resolved review ID after fetch via bug_ID or review_ID.

# ----------------------------------------------------------------------------
# Commits to the underlying Subversion repository.
#
# Only works for SVN and GIT-SVN repositories. Modifies the commit message by
# adding a custom prefix which avoids duplicate work when the script is also
# installed as a pre-commit hook.
# ----------------------------------------------------------------------------

sub commit {
  my $command;
  my $git_svn_url;

  if ( get_git_root() ) {
    # Verify that we're talking about a git-svn repository.
    my @settings = qw(svn-remote.svn.commiturl svn-remote.svn.url); 
    for my $setting ( @settings ) {
      $git_svn_url = `git config --get $setting`;
      if ( $git_svn_url ) {
        last;
      } 
    }
    if ( !$git_svn_url ) {
      print "--commit only valid for Subversion or Git-SVN repositories.\n";
      exit(1);
    }
    # NOTE the prefix here...this is checked when the script runs as a
    # pre-commit hook and is used to tell it to skip everything and exit.
    $command = "git svn dcommit -m \"$prefix [review $rr_id] $message\"";
  } elsif ( get_svn_root() ) {
    # NOTE the prefix here...this is checked when the script runs as a
    # pre-commit hook and is used to tell it to skip everything and exit.
    $command = "svn commit -m '$prefix [review $rr_id] $message'";
  } else {
    print "--commit only valid for Subversion or Git-SVN repositories.\n";
    exit(1);
  }

  print "Executing commit: $command\n";
  my $out = `$command`;
  if ( $? != 0 ) {
    print "$out\n";
    print "Commit failed.\n";
    exit(1);
  }
  print "Commit complete.\n";
}

# ----------------------------------------------------------------------------
# Fetch a review from ReviewBoard based on either bug or review ID.
# 
# Sets $review_exists to true if the review is found. The value in $review is
# updated to contain the review data found. Returns $review_exists.
# ----------------------------------------------------------------------------

sub fetch_code_review {

  if ( $review_id ) {
    print "Checking ReviewBoard for review: $review_id.\n";
    $review_exists =  $review->fetch( $review_id );
    print "No ReviewBoard entry found for: $review_id.\n" unless $review_exists;
  }

  if ( $bug_id and !$review_exists ) {
    print "Checking ReviewBoard for bug id: $bug_id.\n";
    $review_exists = $review->fetch_from_bug( $bug_id );
    print "No ReviewBoard entry found for: $bug_id.\n" unless $review_exists;
  }

  # If we found a review then we can fetch the common ID easily.
  if ( $review_exists ) {
    $rr_id = $review->get_id();
    print "Found ReviewBoard code review: $rr_id.\n";
  }

  return $review_exists;
};

# ----------------------------------------------------------------------------
# Determine if the current directory is part of a GIT-based repository.
#
# Returns the root of the GIT working tree, if cwd is a child directory.
# ----------------------------------------------------------------------------

sub get_git_root {

    # There's only one .git directory per repository.
    my $cwd = getcwd;
    my @dirs = File::Spec->splitdir( $cwd );
    my $path;
    for ( @dirs ) {
        $path = File::Spec->catdir( $path, $_ );
        return $path if -d "$path/.git";
    }
 
    return;
};

# ----------------------------------------------------------------------------
# Determine if we're run as a precommit hook or interactively.
#
# Returns true if execution appears to be interactive/command-line based.
# ----------------------------------------------------------------------------

sub is_interactive {
  return -t STDIN && -t STDOUT;
}

# ----------------------------------------------------------------------------
# Determine if the current directory is part of a Subversion repository.
#
# Returns the root of the Subversion working tree if cwd is a child directory.
# ----------------------------------------------------------------------------

sub get_svn_root {

  # Subversion trees have a .svn directory at every level.
  if ( -d "./.svn" ) {
    # We know we're in a Subversion tree...can we find the root?
    my $cwd = getcwd;
    my @dirs = File::Spec->splitdir( $cwd );
    my $path;
    my $root;
    for ( @dirs ) {
      $path = File::Spec->catdir( $path, $_ );
      if ( -d "./.svn" ) {
        $root = $path;
      }
    }
    return $root;
  }

  return;
};

# ----------------------------------------------------------------------------
# Parse command line arguments and performs minimal "multi-argument" testing.
#
# Sets the values of $review_id and $bug_id from the command line arguments.
# Additional arguments for turning off testing, turning on commits, etc. are
# also set here. This routine also performs checks to make sure arguments which
# have interdependencies (-c and -m for example) are validated.
# ----------------------------------------------------------------------------

sub parse_commandline_args {

  GetOptions(
      'b|bug-id=i' => \$bug_id,
      'c|commit' => \$commit,
      'f|force' => \$force,
      'h|help' => sub { eval { usage(); }; print $@; exit(0) },
      'i|review-id=i' => \$review_id,
      'l|lint' => \$lint,
      't|test' => \$test,
      'm|message=s' => \$message,
      'v|verbose' => \$verbose,
  ) || usage( 'Invalid usage.' );

  # When no review or bug id is available this is a considered 'pre-review'.
  if ( !$review_id && !$bug_id ) {
    $pre_review = 1;
  }

  if ( $message and (length($message) > 0) ) {
    unless ( $message =~ /\[[bB]ug(\:*) (\d+)\]/ or
        $message =~/\[[rR]eview(\:*) (\d+)\]/ ) {
      print "Commit message must include [bug xxx] or [review xxx].\n";
      exit(1);
    }
  } elsif ( $commit ) {
    usage( "No commit message provided. Always use -m with -c." );
  }

  if ( $all ) {
    $test = 1;
    $lint = 1;
  }

  Log::Log4perl->easy_init($verbose ? $DEBUG : $WARN);
};

# ----------------------------------------------------------------------------
# Parse Subversion pre-commit arguments.
#
# Sets the values of $review_id and $bug_id from the proposed commit message.
# The message is extracted from the output of `svnlook log -t ...`. Most
# command-line options aren't available in this mode and all data is taken from
# the transaction and repository data available via svnlook.
# ----------------------------------------------------------------------------

sub parse_precommit_args {

  my $repos = $ARGV[0];
  my $txn = $ARGV[1];

  # Capture the commit message from the transaction.
  $message = `$svnlook log -t "$txn" "$repos"`;
  chomp($message);

  # Verify commit message format/content.
  if ( length($message) == 0 ) {
    print "A commit message with a bug or review ID is mandatory.\n";
    exit(1);
  } else {
    unless ( $message =~ /\[[bB]ug(:*) (\d+)\]/ or
        $message =~/\[[rR]eview(:*) (\d+)\]/ ) {
      print "Commit message must include [bug xxx] or [review xxx].\n";
      exit(1);
    }
  }

  # Parse out the bug number/review id so we can fetch the proper review.
  if ( $message =~ /\[[bB]ug(:*) (\d+)\]/ ) {
    $bug_id = $2
  } 
  if ( $message =~ /\[[rR]eview(:*) (\d+)\]/ ) {
    $review_id = $2
  }

  if ( !$review_id && !$bug_id ) {
    $pre_review = 1;
  }
};

# ----------------------------------------------------------------------------
# Dumps the current environment specific to CRCHECK_* variables.
# ----------------------------------------------------------------------------

sub print_env {
  my $key;
  my $value;

  print "\nCurrent CRCHECK_* Exports:\n";
  while ( ($key, $value) = each %ENV ) {
    if ( $key =~ /^CRCHECK_/ ) {
      print "\texport $key='$value'\n";
    }
  }
};

# ----------------------------------------------------------------------------
# Dumps the current set of flag settings used for execution.
# ----------------------------------------------------------------------------

sub print_flags {

  print "\nCurrent CRCHECK Flags:\n";
  print " -a | --all  " . ($all ? 'true' : 'false') . "\n";
  print " -b | --bug-id  " . $bug_id . "\n" if $bug_id;
  print " -c | --commit  " . ($commit ? 'true' : 'false') . "\n";
  print " -f | --force  " . ($force ? 'true' : 'false') . "\n";
  print " -i | --review-id  " . $review_id . "\n" if $review_id;
  print " -l | --lint  " . ($lint ? 'true' : 'false') . "\n";
  print " -m | --message  " . $message . "\n" if $message;
  print " -t | --test  " . ($test ? 'true' : 'false') . "\n";
  print " -v | --verbose  " . ($verbose ? 'true' : 'false') . "\n";
  print "\n";
}

# ----------------------------------------------------------------------------
# Update related bugzilla bug(s) if a commit is performed.
# ----------------------------------------------------------------------------

sub update_bugzilla {
  # TODO
};

# ----------------------------------------------------------------------------
# Update VersionOne tasks related to any bugs we close.
# ----------------------------------------------------------------------------

sub update_version_one {
  # TODO
};

# ----------------------------------------------------------------------------
# Output a mode-specific usage message.
#
# Produces a simple *NIX style usage message.
# ----------------------------------------------------------------------------

sub usage {
    my $message = shift;
    warn "$message\n" if $message;

    # Output here is based on how we're invoked. No point in putting out command
    # line flag instructions for pre-commit operation :).
    if ( is_interactive() ) {  
      die <<EOI
usage: $0 
        [-a | --all]
        [-b | --bug-id <id>]
        [-c | --commit]
        [-h | --help]
        [-i | --review-id <id>]
        [-l | --lint]
        [-m | --message <message>]
        [-t | --test]
        [-v | --verbose]
EOI
    } else {
      die <<EOP
      usage: svn commit -m "[bug nnnn] .... | [review nnnn] ...."
EOP
    }
};

# ----------------------------------------------------------------------------
# Verify any JavaScript files in the proposed commit are lint-free.
#
# Invokes a specialized linting routine based on whether the script is running
# interactively or as a pre-commit hook.
# ----------------------------------------------------------------------------

sub verify_lintfree_javascript {
  if ( is_interactive() ) {
    verify_lintfree_interactive();
  } else {
    verify_lintfree_precommit();
  }
};

# ----------------------------------------------------------------------------
# Verify any JavaScript files in the proposed commit are lint-free.
#
# Specialization for interactive command line. Depending on whether the script
# is run in a Subversion or Git-SVN repository it will run a slightly different
# 'status' command and parse the results for any *.js files to be linted.
# ----------------------------------------------------------------------------

sub verify_lintfree_interactive {

  my $str;
  my $root;
  my $command;

  # Depending on git vs. svn repository state we'll run either a git status or
  # svn status command line to generate the file list.
  if ( $root = get_git_root() ) {
    print "Git-SVN root: $root\n";
	  $str = `git status | grep 'new file:\\|modified:' | awk -F ':   ' '{ printf "%s\\n", \$2 }'`;
  } elsif ( $root = get_svn_root() ) {
    print "Subversion root: $root\n";
	  $str = `svn status | grep '\.js' | awk '{ printf "%s\\n", \$2 }'`;
  } else {
    print "Unable to locate repository root. Lint validation failed.\n";
    exit(1);
  }

  print "Verifying lint-free JavaScript...\n";

  # Git status in particular can create duplicates for added files you later
  # modify. We'll use a hash to watch for that and skip duplicate lint checks.
  my %done;

  # Track lint errors...we lint all files to avoid repetitive overhead.
  my $errs;

  # Output from lint command executions.
  my $lintout;

  foreach my $line ( split("\n", $str) ) {
    # Watch out for duplicates and skip them.
    if ( $done{$line} ) {
      next;
    }
    $done{$line} = $line;

    # Google Closure checks...warnings only.
    $command = "$glinter $line";
    print "Checking: $line via '$command'\n";
    $lintout = `$command`;
    if ( $? != 0 ) {
      print "$lintout\n";
      # TODO: When code should pass Closure remove comment below.
      #$errs = 1;
    }

    # Yahoo jslint (fatal checks). 
    $command = "$ylinter $line";
    print "Checking: $line via '$command'\n";
    $lintout = `$command`;
    if ( $? != 0 ) {
      print "$lintout\n";
      $errs = 1;
    }
  }

  if ( $errs ) {
    exit(1);
  }
};

# ----------------------------------------------------------------------------
# Verify any JavaScript files in the proposed commit are lint-free.
#
# Specialization for pre-commit hook operation. The output of the Subversion
# `svnlook # changed -t ...` command is examined and parsed to find *.js files.
# To avoid path problems around differing repository checkout roots/configs the
# data is written to a tmp file and the tmp file is linted.
# ----------------------------------------------------------------------------

sub verify_lintfree_precommit {
  print "Verifying lint-free JavaScript...\n";

  # When invoked as a Subversion pre-commit hook we'll get the repository and
  # transaction IDs as arguments.
  my $repos = $ARGV[0];
  my $txn = $ARGV[1];
  my $command;

  # Track lint errors...we lint all files to avoid repetitive overhead.
  my $errs;

  foreach my $line ( `$svnlook changed -t $txn "$repos"` ) {
    chomp($line);
    if ( $line !~ /^([DAUX]).\s\s(.+)$/ ) {
      print "Can't parse [$line].\n";
      exit(1);
    }

    my $action = $1;
    my $file = $2;
    chomp($file);

    # Skip non-JS files...no point in the overhead since we can't lint them.
    if ( $file =~ /\/$/ || $file !~ /\.js/ ) {
      next;
    }
 
    my $fileContent = `$svnlook cat -t $txn "$repos" "$file"`;
    if ( $action =~ /[AU]/ ) {
    
      # Build a temporary file containing the proposed content. This avoids
      # problems with paths which vary across different checkout roots etc. 
      (my $js_fh, my $js_file) = (File::Temp::tempfile(
          "/tmp/$prefix-$$-js.XXXX",
          UNLINK => 1)
      );
      print $js_fh $fileContent; 

      print "Checking: $file\n";

      if ( $linter =~ /gjslint/ ) {
        # Have to feed an extension to the gjslint program or it won't lint the
        # file...it assumes only .js files by default.
        my @file_parts = split(/\./, $js_file);
        my $js_ext = $file_parts[1];
        $command = "$linter --additional_extensions=$js_ext $js_file";
      } else {
        $command = "$linter $js_file";
      }

      my $lint = `$command`;
      if ( $? != 0 ) {
        print "$lint\n";
        $errs = 1;
      }
    }
  }

  # Don't forget to remove the temp file(s) we may have created. This is
  # officially optional, they should be removed on exit.
  File::Temp::cleanup();

  if ( $errs ) {
    exit(1);
  }
};

# ----------------------------------------------------------------------------
# Ensure we have a valid code review we can find on ReviewBoard.
#
# Won't access ReviewBoard once a successful review fetch has occurred, so
# calling this more than once is ok.
# ----------------------------------------------------------------------------

sub verify_review_exists {
  # Make sure we only run this once. Once we've got a viable review we don't
  # need to keep beating on the ReviewBoard server with fetch() calls.
  if ( !$review_exists ) {
    fetch_code_review();
    if ( !$review_exists ) {
      print "You must have a valid code review to commit.\n";
      exit(1);
    }
  }
};

# ----------------------------------------------------------------------------
# Ensure required code review reference has at least one ship-it.
# 
# Relies on verify_review_exists to handle initial fetch. Provided that routine
# passes this routine verifies the ship-it count is non-zero.
# ----------------------------------------------------------------------------

sub verify_review_shipit {
  verify_review_exists();

  my $shipit_count = $review->get_ship_it_count();
  print "Review $rr_id has $shipit_count ship-it(s).\n";
  if ( $shipit_count < $min_shipits ) {
    print "You must have at least $min_shipits ship-it(s) to commit.\n";
    exit(1);
  }
};

# ----------------------------------------------------------------------------
# Verify any related unit tests pass. There should be a Makefile for testing.
#
# This routine works only when crcheck is run from the command line from 
# an SVN or Git-SVN repository directory. When no directory root can be found
# no project Makefile can be located and hence no invocation can occur. The
# target used is 'test' but can be changed by setting CRCHECK_MAKE_TARGET.
# ----------------------------------------------------------------------------

sub verify_tests_passing {

  my $root = get_git_root() || get_svn_root();
  if ( !$root ) {
    print "Unable to locate repository root. Test validation failed.\n";
    exit(1);
  }

  # Makefile should be at root of the repository tree.
  my $makefile = "$root/Makefile";
  unless ( -e "$makefile" ) {
    # Secondary check for a 'trunk' directory below the repository root. This
    # will exist when the original checkout was done at the root rather than at
    # 'trunk' for the Subversion repository.
    $makefile = "$root/trunk/Makefile";
    unless ( -e "$makefile" ) {
      print "No Makefile found. Are you running from the repository root?\n";
      exit(1);
    }
  }

  # Execute a make using whatever target has been defined. If the make is happy
  # we're happy :).
  print "Executing '$maketarget' target in: $makefile\n";
  my $command = "make $maketarget";
  my $out = `$command`;
  if ( $? != 0 ) {
    print "$out\n";
    exit(1);
  }
};

# ============================================================================
# Run :)
# ============================================================================

if ( is_interactive() ) {
  print "Precommit checks running in command mode...\n";
  parse_commandline_args();
} else {
  select STDERR;  # All output in a pre-commit trigger is suppressed, except
                  # what you write to STDERR if exit(1) is ultimately called.
  print "Precommit checks running in repository mode...\n";
  parse_precommit_args();

  # When running in response to a --commit flag the message will be updated 
  # to include a prefix. We can skip all tests when this is true so we avoid
  # the overhead of running all the checks twice.
  if ( $message and ($message =~ /^$prefix /) ) {
    exit(0);
  }
};

# Output the variables controlling operation of the script.
print_env() if $verbose;
print_flags() if $verbose;

# Lint checks can be disabled since not all legacy files will pass.
verify_lintfree_javascript() if $lint;

# Normally run tests, but they can be turned off via command line.
verify_tests_passing() if $test;

# If this is a pre-review check from the command line we'll skip lookup...there
# won't be one anyway.
verify_review_exists() unless $pre_review;
verify_review_shipit() unless $pre_review;

if ( is_interactive() ) {
  print "Precommit testing complete.\n";

  # We can optionally push a true commit...but not if any tests were skipped.
  if ($commit) {
    if ($pre_review || !$test || !$lint) {
      if (!$force) {
        print "Commit cancelled. Run lint/review/test checks to commit.\n";
        exit(1);
      } else {
        print "Commit forced to ignore lint/review/test checks.\n";
      }
    }
    # The commit call will check for a commit message...so we don't have to :).
    commit();
  }
  exit(0);
}

exit(0);

# ============================================================================
# Documentation :)
# ----------------------------------------------------------------------------

__END__
=head1 NAME

B<crcheck> - commit changes to subversion, verifying code review & standards.

=head1 DESCRIPTION 

B<crcheck> allows developers (that's you :)) to commit code to the Subversion
trunk after verifying the code is lint-free, that all unit tests pass, and that
a minimum ReviewBoard code review ship-it count has been received. 

B<crcheck> is a combination command-line pre-commit script and a pre-commit
hook for Subversion. It can be run in either mode, or used in both forms in the
same repository. B<crcheck> can be run in both Subversion and Git-SVN clients.

When run from the command line B<crcheck> requires flags to turn on the code
checks. You must use the -c flag along with the -m flag (for a message) to
request a commit when all checks have passed. A commit request will always
require a valid ReviewBoard code review acquired via either a bug ID or review
ID specified by either -b or -i respectively.

When installed as a Subversion pre-commit hook script B<crcheck> will perform
the same set of tests without any ability to alter command flags or environment.
In this mode the B<crcheck> script will check for a token set by the command 
line execution to avoid duplication of work and costly pre-commit hook blocking.
When this token is found the pre-commit hook logic will assume all tests have
passed and the commit will be processed without additional overhead.

B<crcheck> is intended to work with B<crpost> and B<crfetch> in a process
which supports high-quality coding practices. The code review IDs being
specified come from ReviewBoard and should be created using the B<crpost>
utility. See B<crpost> for more info.

=head1 SYNOPSIS

  # You can run from the command line with either a bug id or review id.
  crcheck [--bug-id <id> | --review-id <id>]

  # You can add lint checks when you're ready to finalize your code.
  crcheck -l

  # You can turn on unit testing when your code is ready for testing.
  crcheck -t
 
  # You can run all checks (lint and tests) by providing the -a flag. 
  crcheck -a

  # You can request a commit if you also provide a message (if checks pass).
  crcheck -c -m "[bug 123] Fixes bug around foos going to bars."
 
  # You can force a commit to happen and bypass checks...but don't :).
  crcheck -f -c -m "[bug 123] Fixes bug around foos going to bars." 

  # Using verbose mode will dump the ENV and flag settings being used.
  crcheck -v

=head1 USAGE

  crcheck
        [-a | --all]
        [-b | --bug-id <id>]
        [-c | --commit]
        [-f | --force]
        [-h | --help]
        [-i | --review-id <id>]
        [-l | --lint]
        [-m | --message <message>]
        [-t | --test]
        [-v | --verbose]


=head1 CONFIGURATION

B<crcheck> supports the following environment variables:

  # Path to the Perl site libraries. [home/y/lib/perl5/site_perl]
  CRCHECK_SITE_PERL
  
  # Path to the Google linter. [/usr/local/bin/gjslint]
  CRCHECK_GOOGLE_LINTER

  # Path to the Yahoo linter. [/home/y/bin/yjslint.sh]
  CRCHECK_YAHOO_LINTER

  # Makefile target to use for running tests via make. [test]
  CRCHECK_MAKE_TARGET

  # Minimum number of ship-its required to allow a commit to proceed. [1]
  CRCHECK_MIN_SHIPITS

  # Prefix used to short-circuit duplicate work in pre-commit hook. [crcheck:]
  CRCHECK_PREFIX

  # Path to the Yahoo! Subversion repository. [svn+ssh://svn.corp.yahoo.com]
  CRCHECK_SVN_URL

  # Path to the Yahoo! ReviewBoard server. [http://codereview.corp.yahoo.com]
  CRCHECK_RB_URL

  # Path to the default Subversion "svnlook" binary. [/usr/bin/svnlook]
  CRCHECK_SVNLOOK

=head1 AUTHORS

=over

=item Scott Shattuck <idearat@yahoo-inc.com>

=back

=cut

# ----------------------------------------------------------------------------
# end
# ============================================================================
