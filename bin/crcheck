#!/usr/bin/env perl
# ============================================================================
# NAME: crcheck
# DESC: A simple pre-commit script checking lint, unit tests, and code review.
#       This script is based on crpost/crfetch by Jay Buffington et. al. but is
#       focused on pre-commit checks rather than ReviewBoard. ReviewBoard is
#       used in this context to verify ship-its and as a checksum drop-box. See
#       the documentation produced via perldoc crcheck for more information.
# AUTH: Scott Shattuck (idearat@yahoo-inc.com)
# NOTE: Copyright (C) 2011, Yahoo Inc., All Rights Reserved.
# ----------------------------------------------------------------------------
#
# TODO:
#       Update to accept a list of file names via stdin so you can limit scope.
#       Update to work with a pure GIT repository environment.
#
# ----------------------------------------------------------------------------

use 5.008;

use strict;
use warnings;

# Add library reference to support running as a pre-commit hook. In that case
# there won't be any environment/path configured unless we do it manually.
use lib ( $ENV{'CRCCHECK_SITE_PERL'} || '/home/y/lib/perl5/site_perl');

use Yahoo::Config::DirTree;
use Yahoo::Bugzilla::Client;
use Yahoo::WebService::ReviewBoard::ReviewRequest;
use Cwd;
use File::Spec;
use Getopt::Long;
use Log::Log4perl qw(:easy);

# ----------------------------------------------------------------------------
# Global variables/constants etc.
# ----------------------------------------------------------------------------

# ---
# Command line argument variables.
# ---

my $bug_id;           # Can be parsed from commit message or command line.
my $commit = 0;       # Follow up success with a [d]commit. Triggered by -m.
my $force = 0;        # Force commit to happen regardless of test state.
my $message;          # A commit message (Implies setting $commit to true).
my $no_review = 1;    # Set when no bug ID or review ID to skip ReviewBoard.
my $review_id;        # Can be parsed from commit message or command line.
my $verbose = 0;      # Turn on more verbose output logging (DEBUG vs. WARN).

# ---
# Constants / Magic Values
# ---

# Path to the Google Closure Linter.
my $gjslinter = $ENV{'CRCHECK_GOOGLE_JSLINTER'} || '/usr/local/bin/gjslint';

# Optional command to run for linting. By default JS files are linted two ways.
my $lintcmd = $ENV{'CRCHECK_LINT_COMMAND'};

# Command string to use to execute 'make' for unit tests. Default is 'make test'.
my $makecmd = $ENV{'CRCHECK_MAKE_COMMAND'} || 'make test';

# Minimum number of ship-its required to allow a commit to proceed.
my $min_shipits = $ENV{'CRCHECK_MIN_SHIPITS'} || 1;

# Path to the Yahoo! Subversion repository.
my $repo_default = $ENV{'CRCHECK_SVN_URL'} || "svn+ssh://svn.corp.yahoo.com";

# Path to the Yahoo! ReviewBoard server.
my $reviewboard = $ENV{'CRCHECK_RB_URL'} || 'http://codereview.corp.yahoo.com';

# Command string to use to create checksum for ensuring code hasn't changed.
my $sumcmd = $ENV{'CRCHECK_CHECKSUM_COMMAND'} || '/sbin/md5 -q';

# Path to the default Subversion "svnlook" binary.
my $svnlook = $ENV{'CRCHECK_SVNLOOK'} || '/usr/bin/svnlook';

# Command string to use to execute unit tests, replacing CRCHECK_MAKE_COMMAND.
my $testcmd = $ENV{'CRCHECK_TEST_COMMAND'};

# Path to the Yahoo! jslint linter.
my $yjslinter = $ENV{'CRCHECK_YAHOO_JSLINTER'} || '/home/y/bin/yjslint.sh';

# ---
# Shared Globals
# ---

my $checksum;       # computed checksum for the current change list.
my $msg_bug;        # any bug id parsed from an optional commit message.
my $msg_review;     # any review id parsed from an optional commit message.
my $review_exists;  # true when the review is found on ReviewBoard.
my $real_id;        # resolved review ID after fetch via bug_ID or review_ID.

# Create a global Review object we can use to interact with ReviewBoard.
my $review = Yahoo::WebService::ReviewBoard::ReviewRequest->new($reviewboard);

# ----------------------------------------------------------------------------
# Invoked in interactive mode to commit to the primary Subversion repository.
#
# Only works for SVN and GIT-SVN repositories. The commit operation is triggered
# by the existence of a valid commit message on the command line.
# ----------------------------------------------------------------------------

sub commit {

  my $command;
  my $git_svn_url;
  my $msg = $message;

  # format message to include one and only one [review: xxx] element, or to
  # ensure we have [force] for tracking workaround commits.
  if ( $force ) {
    if ( $message !~ /[force]/ ) {
      $msg = "[force] $message";
    }
  } else {
    verify_review_exists();
    if ( $message !~ /\[[rR]eview(:*) (\d+)\]/ ) {
      if ( $message !~ /\[[bB]ug(:*) (\d+)\]/ ) {
        $msg = "[review: $real_id] $message";
      }
    }
  }

  if ( get_git_root() ) {
    # Verify that we're talking about a git-svn repository.
    my @settings = qw(svn-remote.svn.commiturl svn-remote.svn.url); 
    for my $setting ( @settings ) {
      $git_svn_url = `git config --get $setting`;
      if ( $git_svn_url ) {
        last;
      } 
    }
    if ( !$git_svn_url ) {
      print "Commit only valid for Subversion or Git-SVN repositories.\n";
      exit(1);
    }
    $command = "git svn dcommit -m \"$msg\"";
  } elsif ( get_svn_root() ) {
    $command = "svn commit -m '$msg'";
  } else {
    print "Commit only valid for Subversion or Git-SVN repositories.\n";
    exit(1);
  }

  print "Executing commit: $command\n";
  my $out = `$command`;
  if ( $? != 0 ) {
    print "$out\n";
    print "Commit failed.\n";
    exit(1);
  }
  print "Commit complete.\n";

};

# ----------------------------------------------------------------------------
# Compute a checksum for the current changed file list.
#
# Uses the proper "status" command for the repository (svn status, git status)
# and computes a checksum from the files in the resulting list. This checksum is
# then used to annotate ReviewBoard for cross-validation during pre-commit.
# ----------------------------------------------------------------------------

sub compute_changeset_checksum {
 
  my $command;
  my $errs;
  my $out;
  my $sum = '';

  # Git status in particular can create duplicates for added files you later
  # modify. We'll use a hash to watch for that and skip duplicate lint checks.
  my %done;

  my @lines = get_changeset_list();
  foreach my $line ( @lines ) {

    # Watch out for duplicates and skip them.
    if ( $done{$line} ) {
      next;
    }
    $done{$line} = $line;

    # We'll append the checksums for each file, then eventually do a single
    # checksum of that longer checksum string.
    $command = "$sumcmd $line";
    print "Checksumming via '$sumcmd $line'\n";
    $out = `$command`;

    if ( $? != 0 ) {
      print "$out\n";
      $errs = 1;
    }
    chomp($out);
    $sum = $sum . $out;
  }

  # Now checksum our checksum string. This will shorten it down to a single
  # 32 character value no matter how many files were in our list.
  $checksum = `echo "$sum" | $sumcmd`;
  chomp($checksum);

  if ( $errs ) { 
    exit(1);
  }
};

# ----------------------------------------------------------------------------
# Compute a checksum for the current transaction files.
#
# Use the text of the files being updated to compute a checksum for the state of
# the files. This sum can then be compared to the sum produced during the last
# test run to ensure no code changes have occurred since the last test run.
# ----------------------------------------------------------------------------

sub compute_precommit_checksum {
  my $repos = shift;
  my $txn = shift;

  my $command;
  my $errs;
  my $out;
  my $sum = '';

  foreach my $line ( `$svnlook changed -t $txn "$repos"` ) {
    chomp($line);
    if ( $line !~ /^([DAUX]).\s\s(.+)$/ ) {
      print "Can't parse [$line].\n";
      exit(1);
    }

    my $action = $1;
    my $file = $2;
    chomp($file);

    # Grab text of added/updated files (A or U). 
    my $fileContent = `$svnlook cat -t $txn "$repos" "$file"`;
    if ( $action =~ /[AU]/ ) {

      # Build a temporary file containing the proposed content. This avoids
      # problems with paths which vary across different checkout roots etc. 
      (my $fh, my $tmpfile) = (File::Temp::tempfile(
          "/tmp/crcheck-$$-js.XXXX",
          UNLINK => 1)
      );
      print $fh $fileContent; 

      # Note we print the original file name here, not the temp file, but we do
      # the checksum on our temporary copy.
      $command = "$sumcmd $tmpfile";
      print "Checksumming via '$sumcmd $file'\n";

      # We'll append the checksums for each file, then eventually do a single
      # checksum of that longer checksum string.
      $out = `$command`;
      if ( $? != 0 ) {
        print "$sum\n";
        $errs = 1;
      }
      # Strip whitespace off any chunks so we can reassemble cleanly.
      chomp($out);
      $sum = $sum . $out;
    }
  }

  # Don't forget to remove the temp file(s) we may have created. This is
  # officially optional, they should be removed on exit.
  File::Temp::cleanup();

  # Now checksum our checksum string. This will shorten it down to a single
  # 32 character value no matter how many files were in our list.
  $checksum = `echo "$sum" | $sumcmd`;
  chomp($checksum);

  if ( $errs ) {
    exit(1);
  }
};

# ----------------------------------------------------------------------------
# Fetch a review from ReviewBoard based on either bug or review ID.
# 
# Sets $review_exists to true if the review is found. The value in $review is
# updated to contain the review data found. Returns $review_exists.
# ----------------------------------------------------------------------------

sub fetch_code_review {

  if ( $review_id ) {
    print "Checking ReviewBoard for review: $review_id.\n";
    $review_exists =  $review->fetch( $review_id );
    print "No ReviewBoard entry found for: $review_id.\n" unless $review_exists;
  }

  if ( $bug_id and !$review_exists ) {
    print "Checking ReviewBoard for bug id: $bug_id.\n";
    $review_exists = $review->fetch_from_bug( $bug_id );
    print "No ReviewBoard entry found for: $bug_id.\n" unless $review_exists;
  }

  # If we found a review then we can fetch the common ID easily.
  if ( $review_exists ) {
    $real_id = $review->get_id();
    print "Found ReviewBoard code review: $real_id.\n";
  }

  return $review_exists;
};

# ----------------------------------------------------------------------------
# Return a string of filenames in the current repository "change set".
#
# Using the appropriate repository status command this method returns a string
# of newline-separated files to be checked for lint, checksummed, etc.
# ----------------------------------------------------------------------------

sub get_changeset_list {

  my $root;
  my $str;

  # Depending on git vs. svn repository state we'll run either a git status or
  # svn status command line to generate the file list.
  if ( $root = get_git_root() ) {
    print "Git-SVN root: $root\n";
	  $str = `git status | grep 'new file:\\|modified:' | awk -F ':   ' '{ printf "%s\\n", \$2 }'`;
  } elsif ( $root = get_svn_root() ) {
    print "Subversion root: $root\n";
	  $str = `svn status | grep -v '^D' | grep -v '^\?' | awk '{ printf "%s\\n", \$2 }'`;
  } else {
    print "Unable to locate repository root. Changeset listing failed.\n";
    exit(1);
  }

  # Note that we split and sort here. The sort is particularly important so that
  # consumers of the list get consistent ordering (which is necessary for the
  # checksum process in particular).
  return sort(split("\n", $str));
};

# ----------------------------------------------------------------------------
# Determine if the current directory is part of a GIT-based repository.
#
# Returns the root of the GIT working tree, if cwd is a child directory.
# ----------------------------------------------------------------------------

sub get_git_root {

    # There's only one .git directory per repository.
    my $cwd = getcwd;
    my @dirs = File::Spec->splitdir( $cwd );
    my $path;

    for ( @dirs ) {
        $path = File::Spec->catdir( $path, $_ );
        return $path if -d "$path/.git";
    }
 
    return;
};

# ----------------------------------------------------------------------------
# Determine if we're run as a precommit hook or interactively.
#
# Returns true if execution appears to be interactive/command-line based.
# ----------------------------------------------------------------------------

sub is_interactive {
  return -t STDIN && -t STDOUT;
};

# ----------------------------------------------------------------------------
# Determine if the current directory is part of a Subversion repository.
#
# Returns the root of the Subversion working tree if cwd is a child directory.
# ----------------------------------------------------------------------------

sub get_svn_root {

  # Subversion trees have a .svn directory at every level.
  if ( -d "./.svn" ) {
    # We know we're in a Subversion tree...can we find the root?
    my $cwd = getcwd;
    my @dirs = File::Spec->splitdir( $cwd );
    my $path;
    my $root;

    for ( @dirs ) {
      $path = File::Spec->catdir( $path, $_ );
      if ( -d "./.svn" ) {
        $root = $path;
      }
    }
    return $root;
  }

  return;
};

# ----------------------------------------------------------------------------
# Parse command line arguments and performs minimal "multi-argument" testing.
#
# Sets control variables based on the settings of any command line arguments.
# This routine also performs checks to make sure args with interdependencies
# (-c and -m for example) are validated.
# ----------------------------------------------------------------------------

sub parse_commandline_args {

  GetOptions(
      'b|bug-id=i' => \$bug_id,
      'f|force' => \$force,
      'h|help' => sub { eval { usage(); }; print $@; exit(0) },
      'i|review-id=i' => \$review_id,
      'm|message=s' => \$message,
      'v|verbose' => \$verbose,
  ) || usage( 'Invalid usage.' );

  # Parse any related commit message. This may provide a review/bug ID in case
  # they weren't provided on the command line.
  parse_commit_message();

  # Verify the IDs we got from any command line flags and/or the commit message
  # are "compatible" in that they all point to the same "real" review ID.
  resolve_review_id();

  Log::Log4perl->easy_init($verbose ? $DEBUG : $WARN);
};

# ----------------------------------------------------------------------------
# Parse any commit message that may exist in an attempt to find a review ID.
#
# Commit messages can contain text of the form [bug: bug_id] or [review:
# review_id] which should be parsed before assuming no bug/review ID has been
# provided. This routine checks for those values and updates $msg_[bug|review].
# ----------------------------------------------------------------------------

sub parse_commit_message {

  if ( $message and (length($message) > 0) ) {

    # Any viable commit message implies an intent to commit.
    $commit = 1;

    if ( $message =~ /\[[bB]ug(:*) (\d+)\]/ ) {
      print "Found bug id: $2\n";
      $msg_bug = $2
    } 

    # Odds are that only one is present, but if for some reason there are both bug
    # and review IDs in the message any review ID will 'win'.
    if ( $message =~ /\[[rR]eview(:*) (\d+)\]/ ) {
      print "Found review id: $2\n";
      $msg_review = $2
    }

    # A commit message can also include [force] to force the commit to happen. 
    if ( $message =~ /\[force\]/ ) {
      $force = 1;
    }
  }
};

# ----------------------------------------------------------------------------
# Parse Subversion pre-commit arguments.
#
# Sets the values of $review_id and $bug_id from the proposed commit message.
# The message is extracted from the output of `svnlook log -t ...`. Most
# command-line options aren't available in this mode and all data is taken from
# the transaction and repository data available via svnlook.
# ----------------------------------------------------------------------------

sub parse_precommit_args {

  my $repos = $ARGV[0];
  my $txn = $ARGV[1];

  # Capture the commit message from the transaction.
  $message = `$svnlook log -t "$txn" "$repos"`;
  chomp($message);

  # Verify commit message format/content.
  if ( length($message) == 0 ) {
    print "A commit message with a bug or review ID is mandatory.\n";
    exit(1);
  } else {
    unless ( $message =~ /\[[bB]ug(:*) (\d+)\]/ or
        $message =~/\[[rR]eview(:*) (\d+)\]/ or 
        $message =~ /\[force\]/ ) {
      print "Commit message must include [bug xxx], [review xxx], or [force].\n";
      exit(1);
    }
  }

  # Parse the commit message to populate any bug/review ID.
  parse_commit_message();

  # Verify the IDs we got from any command line flags and/or the commit message
  # are "compatible" in that they all point to the same "real" review ID.
  resolve_review_id();

  # If parsing the commit message didn't provide a viable bug or review ID we
  # can't continue unless the comment included some form of "force" command.
  if ( $no_review ) {
    unless ($force) {
      print "No review found. Commit cancelled.";
      exit(1);
    }
  }

  # Compute checksum now since we've got access to the repos/txn properties.
  compute_precommit_checksum($repos, $txn);
};

# ----------------------------------------------------------------------------
# Dumps the current environment specific to CRCHECK_* variables.
# ----------------------------------------------------------------------------

sub print_env {
  my $key;
  my $value;

  print "\nCurrent CRCHECK_* Exports:\n";
  while ( ($key, $value) = each %ENV ) {
    if ( $key =~ /^CRCHECK_/ ) {
      print "\texport $key='$value'\n";
    }
  }
};

# ----------------------------------------------------------------------------
# Dumps the current set of flag settings used for execution.
# ----------------------------------------------------------------------------

sub print_flags {

  print "\nCurrent CRCHECK Flags:\n";
  print " -b | --bug-id  " . $bug_id . "\n" if $bug_id;
  print " -f | --force  " . ($force ? 'true' : 'false') . "\n";
  print " -i | --review-id  " . $review_id . "\n" if $review_id;
  print " -m | --message  " . $message . "\n" if $message;
  print " -v | --verbose  " . ($verbose ? 'true' : 'false') . "\n";
  print "\n";
};

# ----------------------------------------------------------------------------
# Verify we've got a consistent specification for the review/bug ID.
#
# Verify that bug and review ids, regardless of how they were specified,
# ultimately point to a single consistent "real review id". This method also
# updates the $no_review flag which drives logic elsewhere in the script.
# ----------------------------------------------------------------------------

sub resolve_review_id {

  if ( $msg_bug && $bug_id && ( $msg_bug ne $bug_id ) ) {
    usage( "Incompatible bug IDs: $bug_id and $msg_bug" );
  }
  $bug_id ||= $msg_bug;
  
  if ( $msg_review && $review_id && ( $msg_review ne $review_id ) ) {
    usage( "Incompatible review IDs: $review_id and $msg_review" );
  }
  $review_id ||= $msg_review;

  # If we have either a request or bug ID we've got some specification intended
  # to imply there's a review to be checked/validated.
  if ( $review_id or $bug_id ) {
    $no_review = 0;
  }
};

# ----------------------------------------------------------------------------
# Update related bugzilla bug(s) if a commit is performed.
# ----------------------------------------------------------------------------

sub update_bugzilla {
  # TODO
};

# ----------------------------------------------------------------------------
# Update VersionOne tasks related to any bugs we close.
# ----------------------------------------------------------------------------

sub update_version_one {
  # TODO
};

# ----------------------------------------------------------------------------
# Updates the active code review to show when lint/test passage occurred.
#
# Places a checksum in the "tests run" field of the ReviewBoard entry for the
# current code review. This checksum is checked during pre-commit operation to
# ensure that the lint/test runs were done at the command line before any
# attempt to commit was made.
# ----------------------------------------------------------------------------

sub update_review_checksum() {

  my $sum;
  my $chunk;

  verify_review_exists();
  compute_changeset_checksum();

  my $testing = $review->{rr}->{testing_done};
  if ( $testing and (length($testing) > 0) ) {
    # Look for a pre-existing value and be prepared to remove/update it.
    if ( $testing =~ /^\[crcheck: ([^\]]*)\]/ ) {
      $sum = $1;
      my @chunks = split(/\]/, $testing);
      $chunk = $chunks[1];
    } else {
      $chunk = $testing;
    }

    # Strip whitespace off any chunks so we can reassemble cleanly.
    for ($chunk) {
      s/^\s+//;
      s/\s+$//;
    }
    $testing = "[crcheck: $checksum]\n\n" . $chunk
  } else {
    $testing = "[crcheck: $checksum]";
  }

  # Don't "edit" the field if the value isn't really changing.
  if ( $sum ne $checksum ) {
    $review->_set_field( 'testing_done', $testing);
    $review->publish();
  }
};

# ----------------------------------------------------------------------------
# Output a mode-specific usage message.
#
# Produces a simple *NIX style usage message.
# ----------------------------------------------------------------------------

sub usage {
    my $message = shift;
    warn "$message\n" if $message;

    # Output here is based on how we're invoked. No point in putting out command
    # line flag instructions for pre-commit operation :).
    if ( is_interactive() ) {  
      die <<EOI
usage: $0 
        [-b | --bug-id <id>]
        [-f | --force]
        [-h | --help]
        [-i | --review-id <id>]
        [-m | --message <message>]
        [-v | --verbose]

        Message is required to trigger a commit. Message must include a bug ID,
        review ID, or [force] to cause a commit.
EOI
    } else {
      die <<EOP
      usage: svn commit -m "[bug nnnn] .... | [review nnnn] .... | [force] ..."
EOP
    }
};

# ----------------------------------------------------------------------------
# Verify that there is a usable code review and that it can be committed.
#
# Checks to ensure that a review can be found, that it has the proper number of
# ship-its, and that there is a lint/test run checksum ensuring that the code
# meets the automated quality criteria.
# ----------------------------------------------------------------------------

sub verify_committable {

  # Everything can be ignored if --force was set or commit message had [force].
  if ( $force ) {
    return;
  }

  verify_review_checksum();
  verify_review_shipit();
};

# ----------------------------------------------------------------------------
# Verify added/updated files in the proposed commit are lint-free.
#
# Specialization for interactive command line. Depending on whether the script
# is run in a Subversion or Git-SVN repository it will run a slightly different
# 'status' command and parse the results for any files to be linted.
# ----------------------------------------------------------------------------

sub verify_lintfree {

  # If there's an externally defined lint execution command use that as a
  # replacement for the default of trying to run only the JS linters.
  if ( $lintcmd ) {
    print "Initiating lint check via '$lintcmd'\n";
    my $out = `$lintcmd`;
    if ( $? != 0 ) {
      print "$out\n";
      exit(1);
    }
    return;
  }

  # ---
  # lint default.
  # ---

  my $root;
  my $command;

  print "Verifying lint-free file content...\n";

  # Git status in particular can create duplicates for added files you later
  # modify. We'll use a hash to watch for that and skip duplicate lint checks.
  my %done;

  # Track lint errors...we lint all files to avoid repetitive overhead.
  my $errs;

  # Output from lint command executions.
  my $lintout;

  my @lines = get_changeset_list();

  foreach my $line ( @lines ) {
    # Watch out for duplicates and skip them.
    if ( $done{$line} ) {
      next;
    }
    $done{$line} = $line;

    # Don't run a non-JS file through a JS linter...they don't like it :).
    if ( $line =~ /\.js$/ ) {

      # Google Closure checks...warnings only.
      $command = "$gjslinter $line";
      print "Checking: $line via '$command'\n";
      $lintout = `$command`;
      if ( $? != 0 ) {
        print "$lintout\n";
        # TODO: When code should pass Closure remove comment below.
        #$errs = 1;
      }

      # Yahoo jslint (fatal checks). 
      $command = "$yjslinter $line";
      print "Checking: $line via '$command'\n";
      $lintout = `$command`;
      if ( $? != 0 ) {
        print "$lintout\n";
        $errs = 1;
      }
    } else {
      print "Skipping lint check of $line\n";
      next;
    }
  }

  if ( $errs ) {
    exit(1);
  }
};

# ----------------------------------------------------------------------------
# Ensure we have a valid code review we can find on ReviewBoard.
#
# Won't access ReviewBoard once a successful review fetch has occurred, so
# calling this more than once is ok.
# ----------------------------------------------------------------------------

sub verify_review_exists {
  # Make sure we only run this once. Once we've got a viable review we don't
  # need to keep beating on the ReviewBoard server with fetch() calls.
  if ( !$review_exists ) {
    fetch_code_review();
    if ( !$review_exists ) {
      print "You must have a valid code review to commit.\n";
      exit(1);
    }
  }
};

# ----------------------------------------------------------------------------
# Ensure required code review reference has at least one ship-it.
# 
# Relies on verify_review_exists to handle initial fetch. Provided that routine
# passes this routine verifies the ship-it count is non-zero.
# ----------------------------------------------------------------------------

sub verify_review_shipit {
  verify_review_exists();

  my $shipit_count = $review->get_ship_it_count();
  print "Review $real_id has $shipit_count ship-it(s).\n";

  if ( $shipit_count < $min_shipits ) {
    print "You must have at least $min_shipits ship-it(s) to commit.\n";
    exit(1);
  }
};

# ----------------------------------------------------------------------------
# Verifies the current review shows a lint/test checksum that ensures no code
# has been changed since the last valid lint/test run was performed.
# ----------------------------------------------------------------------------

sub verify_review_checksum() {

  # Must have already computed a checksum value for the pre-commit operation.
  if ( !$checksum ) {
    exit(1);
  }

  verify_review_exists();

  my $sum;
  my $testing = $review->{rr}->{testing_done};

  if ( $testing and (length($testing) > 0) ) {
    if ( $testing =~ /^\[crcheck: ([^\]]*)\]/ ) {
      $sum = $1;

      # If our computed checksums match we can return before hitting the exit(1)
      # at the bottom of this routine.
      if ( $sum eq $checksum ) {
        return;
      }
    }
  }

  exit(1);
};

# ----------------------------------------------------------------------------
# Ensure that the command is being run at a repository root. 
#
# The current working directory and repository root are checked against each
# other to ensure the commands will find all necessary resources/information.
# ----------------------------------------------------------------------------

sub verify_run_at_root {
  my $root = get_git_root() || get_svn_root();
  if ( !$root ) {
    usage("Unable to locate your repository's root directory.\n");
  }

  my $cwd = getcwd;
  unless ($cwd eq $root) {
    usage("Sorry, you must run crcheck at your repository root.\n");
  }
};

# ----------------------------------------------------------------------------
# Verify any related unit tests pass. There should be a Makefile for testing.
#
# This routine works only when crcheck is run from the command line from 
# an SVN or Git-SVN repository directory. When no directory root can be found
# no project Makefile can be located and hence no invocation can occur. The
# target used is 'test' but can be changed by setting CRCHECK_MAKE_TARGET.
# ----------------------------------------------------------------------------

sub verify_tests_passing {

  # If there's an externally defined test execution command use that as a
  # replacement for the default of trying to run a 'make test'.
  if ( $testcmd ) {
    print "Initiating unit tests via '$testcmd'\n";
    my $out = `$testcmd`;
    if ( $? != 0 ) {
      print "$out\n";
      exit(1);
    }
    return;
  }

  # ---
  # 'make test' default.
  # ---

  my $root = get_git_root() || get_svn_root();
  if ( !$root ) {
    print "Unable to locate repository root. Test validation failed.\n";
    exit(1);
  }

  # Makefile should be at root of the repository tree.
  my $makefile = "$root/Makefile";
  unless ( -e "$makefile" ) {
    # Secondary check for a 'trunk' directory below the repository root. This
    # will exist when the original checkout was done at the root rather than at
    # 'trunk' for the Subversion repository.
    $makefile = "$root/trunk/Makefile";
    unless ( -e "$makefile" ) {
      print "No Makefile found. Are you running from the repository root?\n";
      exit(1);
    }
  }

  # Execute a make using whatever target has been defined. If the make is happy
  # we're happy :).
  print "Initiating unit tests via '$makecmd'\n";
  my $out = `$makecmd`;
  if ( $? != 0 ) {
    print "$out\n";
    exit(1);
  }
};

# ============================================================================
# Run :)
# ============================================================================

if ( is_interactive() ) {

  # Running anywhere other than the repository root will cause issues later.
  verify_run_at_root();

  parse_commandline_args();

  # Output the control variables after we've done all parsing/validation.
  if ( $verbose ) {
    print_env();
    print_flags();
  }

  # If we're being invoked to perform a commit we don't run tests/lint, we
  # assume that's been done at least once prior to the invocation with a commit
  # message. This avoids extra lint/test time for the most common workflows.
  if ( !$commit ) {

    verify_lintfree();
    verify_tests_passing();
  
    # If there's a related review we also update the review checksum so we can
    # tell during pre-commit whether the code has changed since the last test.
    unless ( $no_review ) {
      update_review_checksum();
    }
  } else {

    if ( $no_review && !$force ) {
      print "Commit cancelled. No related code review specified.\n";
      exit(1);
    }

    # The commit call will check for a commit message or construct one if being
    # forced via the --force flag.
    commit();
  }
} else {

  select STDERR;  # All output in a pre-commit trigger is suppressed, except
                  # what you write to STDERR if exit(1) is ultimately called.

  parse_precommit_args();

  # Must have a real_id (true review id) acquired from either explicit review
  # id or a related bug id. Once that's available we validate the review.
  verify_committable();
};

exit(0);

# ============================================================================
# Documentation :)
# ----------------------------------------------------------------------------

__END__
=head1 NAME

B<crcheck> - verify coding standards and code review ship-it prior to commit.

=head1 DESCRIPTION 

B<crcheck> allows developers to commit code to the Subversion trunk after
verifying the code is lint-free, that all unit tests pass, and that a minimum
ReviewBoard code review ship-it count has been received. 

B<crcheck> is a combination command-line developer tool and a pre-commit
hook for Subversion. It can be run in either mode, or used in both forms in the
same repository. B<crcheck> can be run in both Subversion and Git-SVN clients.

When run from the command line B<crcheck> will automatically invoke lint checks
and unit tests (via either external commands or internal defaults). The internal
default lint operation invokes both the yjslint and gjslint commands. The
default for unit testing is to locate a Makefile and attempt to run 'make test'.
For projects where these aren't sufficient or appropriate you can adjust the
operation by defining CRCHECK_LINT_COMMAND and CRCHECK_TEST_COMMAND variables.

To commit code you must use the -m flag (for a commit message). Commits also
require a valid ReviewBoard code review acquired via either a bug ID or review
ID. A commit can also be "forced" by using specific syntax in the message text.

=head1 DEVELOPMENT

During development you run the crcheck script from the command line. You can run
the script as many times as you like, but you should note that each iteration
which specifies a review or bug will cause the associated review to be updated.
This can annoy folks with too many emails, so it's best to only specify the
review when you're running your final lint/test check prior to committing. So,
to just run lint/test code simply invoke the script with no flags:

  crcheck

During fast-paced development cycles you may want to turn off lint/test checks
respectively. You can do that by using a "no-op" command as your setting for the
CRCHECK_LINT_COMMAND and/or the CRCHECK_TEST_COMMAND. For example, you could map
those to a simple 'echo' to avoid overhead. Be aware however, that circumventing
the script in this fashion is likely to lead to broken builds/commits if you
forget to reset these values before you do your commits. Better to just be
patient and run the linter/tests each time :).

When your code has passed through code review and is ready to commit you should
run the script one last time, providing the review ID either directly or
indirectly via a related bug ID:

  crcheck -b BUG_ID 
or
  crcheck -i REVIEW_ID

When run with a bug or review ID the script will not only run lint and unit
tests but it will also update the code review with a checksum for the clean
code. This checksum must exist or any attempt to commit the code will fail.

=head1 COMMITTING

When you're ready to commit your code you should perform the following steps:

1. Confirm your CRCHECK_LINT_COMMAND is actually running lint :).
2. Confirm your CRCHECK_TEST_COMMAND is invoking all your team's tests.
3. Confirm you ran the script with the final code with a -b or -i flag.
4. Run the script with a -m and provide a commit message similar to any of:

  crcheck -i XXXXX -m "Repaired bug where foos visit bars."
  crcheck -b NNNNN -m "Repaired bug where foos visit bars."

  crcheck -m "[review XXXXX] Repaired bug where foos visit bars."
  crcheck -m "[bug NNNNN] Repaired bug where foos visit bars."

  crcheck -m "[force] Repaired bug where foos visit bars."

Note that the last option, [force] is provided for emergency use only. You
should only use this option if a production system is down and you can't get a
code review in the time available. Note that the logs will show forced commits.

=head1 PRECOMMIT HOOK

When installed as a Subversion pre-commit hook script B<crcheck> will use the
transaction data to locate the commit message. The commit message must contain
either [bug bug_id] or [review review_id] or the commit will fail (Unless you
use [force]...which you shouldn't do ;)). When either of the required ID values
is provided the pre-commit hook checks ReviewBoard for a matching review, a
minimum ship-it count, and proof that that command line version of the script
has successfully been executed for that review. This latter check helps ensure
that all checks have been run without causing the pre-commit hook itself to
block while running unit tests or long validations. Instead, the hook script
computes a checksum and compares it to the last successful checksum in the
review. IFF those values match the commit is allowed to proceed.

B<crcheck> is intended to work with B<crpost> and B<crfetch> in a process
which supports high-quality coding practices. The code review IDs being
specified come from ReviewBoard and should be created using the B<crpost>
utility. See B<crpost> for more info.

=head1 SYNOPSIS

  # For simple development testing just run crcheck with no flags.
  crcheck

  # When you are ready to update the review with a commit checksum run 
  # crcheck with either a bug id or review id.
  crcheck [--bug-id <id> | --review-id <id>]

  # When you are ready to commit use -m with a message. The message can include
  # a bug or review in brackets, or you can specify those using -b or -i.
  crcheck -m "[bug 123] Fixes bug around foos going to bars."
 
  # You can force a commit to happen and bypass checks...but don't :).
  crcheck -f -m "[bug 123] Fixes bug around foos going to bars." 

  # Using verbose mode will dump the ENV and flag settings being used in
  # conjunction with doing any other processing you've defined.
  crcheck -v

=head1 USAGE

  crcheck
        [-b | --bug-id <id>]
        [-f | --force]
        [-h | --help]
        [-i | --review-id <id>]
        [-m | --message <message>]
        [-v | --verbose]


=head1 CONFIGURATION

B<crcheck> supports the following environment variables:

  # Path to the Perl site libraries. [home/y/lib/perl5/site_perl]
  CRCHECK_SITE_PERL
  
  # Path to the Google JavaScript linter. [/usr/local/bin/gjslint]
  CRCHECK_GOOGLE_JSLINTER

  # Path to the Yahoo JavaScript linter. [/home/y/bin/yjslint.sh]
  CRCHECK_YAHOO_JSLINTER
  
# Command string to use to generate file checksums. [/sbin/md5 -q]
  CRCHECK_CHECKSUM_COMMAND

  # Command string to use for running lint using your own command line.
  CRCHECK_LINT_COMMAND

  # Command string to use for running tests via make. [make test] Note that this
  # setting is ignored if you have CRCHECK_TEST_COMMAND set.
  CRCHECK_MAKE_COMMAND
  
  # Command string to use for running tests using your own command line.
  CRCHECK_TEST_COMMAND

  # Minimum number of ship-its required to allow a commit to proceed. [1]
  CRCHECK_MIN_SHIPITS

  # Path to the Yahoo! Subversion repository. [svn+ssh://svn.corp.yahoo.com]
  CRCHECK_SVN_URL

  # Path to the Yahoo! ReviewBoard server. [http://codereview.corp.yahoo.com]
  CRCHECK_RB_URL

  # Path to the default Subversion "svnlook" binary. [/usr/bin/svnlook]
  CRCHECK_SVNLOOK

=head1 AUTHORS

=over

=item Scott Shattuck <idearat@yahoo-inc.com>

=back

=cut

# ----------------------------------------------------------------------------
# end
# ============================================================================
